{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 5806808626836116951,
  "abi": {
    "parameters": [
      {
        "name": "signer_pub_x_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signer_pub_y_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "squad_player_ids",
        "type": {
          "kind": "array",
          "length": 11,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "squad_points",
        "type": {
          "kind": "array",
          "length": 11,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "player_points_merkle_paths",
        "type": {
          "kind": "array",
          "length": 11,
          "type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "array",
              "length": 32,
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "player_points_root",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "squad_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "total_points",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "player_points_merkle_paths": [{ "start": 150, "end": 1558 }],
      "player_points_root": [{ "start": 1558, "end": 1590 }],
      "signature": [{ "start": 64, "end": 128 }],
      "signer_pub_x_key": [{ "start": 0, "end": 32 }],
      "signer_pub_y_key": [{ "start": 32, "end": 64 }],
      "squad_hash": [{ "start": 1590, "end": 1622 }],
      "squad_player_ids": [{ "start": 128, "end": 139 }],
      "squad_points": [{ "start": 139, "end": 150 }],
      "total_points": [{ "start": 1622, "end": 1623 }]
    },
    "return_type": null,
    "return_witnesses": []
  },
  "bytecode": "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",
  "debug_symbols": "tdzRah3nFYbhe9GxKfrXzLwz41spPQhtCoHglNpnxvdeQmKZEu1aPKGnRkvalj8J9Hr0fH76+Ze///Dpp18+fHx6//lpNdvT+79+fvr4rx8+/PoHHz/98O9PT+/3fd49/fjhH0/vj22+vHv6508///j0fru/vPvDm665vr7t2vb75Y339eVv7379APtrH+C4+/2o8/jfH2CO4/c3nbtv7/75tdeyZv/6WmZtf3wtx//rtfz27vuT735bX1/+tu3f+at+79N+vvZa1py9XK3/+pf97eqiq1uutme6WnQ1dLXR1U5XB11FV7SNjbax0TZ22sZO29hpGzttY6dt7LSNnbYx21/Wq3+1aT+/fu9rv759w5lvh7seHnqYHp56eOnhjYfzrIdLD0cPdTmjyxldzuhyRpczupzR5Wy6nE2Xs+lyNl3OpsvZdDmbLmfT5Wy6nE2Xs+tydl3OrsvZdTm7LmfX5ey6nF2Xs+tydl3Oocs5dDmHLufQ5Ry6nEOXc+hyDl3Oocs5dDnpctLlpMtJl5MuJ11Oupx0Oely0uWcupxTl3Pqck5dzqnLOXU5py7n1OWcupxTl3Ppci5dzqXLuXQ5ly7n0uVcupxLl3Ppci5dzq3LuXU5ty7n1uXcupxbl3Prcm5dzq3LuXU56/mZLxdfDl9yDXzmHPjMPfCZg+AzF8FnToLPvKHFG1q8ocUb8qLsSdmbskdlr8qelbkrLw7Li8vy4rS8uC0vjsuL6/LivLy4Ly8OzIsL8+LEvLgxL47Miyvz4sy8uDMvDs2LS/Pi1Ly4NS+OzYtr8+LcvHb/31HeEBfnxcl5cXNeHJ0XV+fF2Xlxd14cnheX58XpeXF7XhyfF9fnxfl5cX9eHKAXF+jFCXpxg14coVf+nAZviDv04hC9uEQvTtGLW/TiGL24Ri/O0Yt79Dr9YR/eECfpxU16cZReXKUXZ+nFXXpxmF5cphen6XX5E2O8Ia7Ti/P04j69OFAvLtSLE/XiRr04Ui+u1Ov2xw79uUN+8JA79XCnHu7Uw516uFMPd+rhTj3cqYc79Sx/eJU3xJ16uFMPd+rhTj3cqYc79XCnHn/+2R+A/hNPQPOG/Blofwjan4L2x6D9OWh/EJo79XCnHu7Us/lj9Lwh7tTDnXq4Uw936uFOPdyphzv1cKce7tSz++9i8Ia4Uw936uFOPdyphzv1cKce7tTDnXq4Uw936uFOPdyphzv1cKce7tTDnXq4Uw936uFOPdypJ/+tMN4Qd+rhTj3cqYc79XCnHu7Uw516uFMPd+o5/VcLeUPcqYc79XCnHu7Uw516HpXfc14uz/31y1MvH3TNc1tfL89te/1y58vXX+15bC+Xx/365cWXN15uDxrjWy4XX574ud0eFLS3XN56+aCgveVy8eXo5/ZBQXvL5c6XB1/GlydfPthQ3y7P9frlrZfDX2XDX2XDGxre0PCGhjc0vKHhDc3Fl/ydeuMNbbyhjTe08YY23tDGG9p4QxtvaOMNbbyhnTe084Z23tDOG9p5QztvaOcN7byhnTe084YO3tDBG3pUs777E8D2qGa94TK+PPny4ssHP0Xe98vn9vl89fJRzXrD5YOfIu/95dXex+uXw5cbX+58efBlfHny5cWXt14+qllvuOQNnbyhkzd08oZO3tDJGzp5Qydv6OQNXbyhizd08YYu3tDFG7p4Qxdv6OINXbyhizd084Zu3tBtG0qZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHlHlMmceUeUyZx5R5TJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5TJjHL1/+Aw==",
  "file_map": {
    "39": {
      "source": "use dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 4;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    squad_player_ids: [u8; 11],\n    squad_points: [u8; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    player_points_root: pub [u8; 32],\n    squad_hash: pub [u8; 32],\n    total_points: pub u8\n) {\n    // verify ECDSA signature\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, squad_hash);\n    // assert(recoveredAddress == computedAddress);\n\n    // verify the merkle path of the point to confirm that is actually the points of the player\n    // for i in squad_player_ids {\n    //     let computed_root= compute_merkle_root(\n    //         squad_points[i], // leaf\n    //         squad_player_ids[i], // index\n    //         player_points_merkle_paths[i] // merkle proof\n    //     );\n    // assert(computed_root == player_points_root);\n    // }\n\n    // sum all points and return it back to the contract\n    let mut calculated_total_points: u8 = 0;\n    for point in squad_points {\n        calculated_total_points+=point as u8;\n    }\n    // assert(calculated_total_points == total_points);\n}\n\nfn concatenate_player_ids_with_salt(squad_player_ids: [u8; 11], player_ids_salt: [u8; 32]) -> [u8; 43] {\n    let mut combined_array: [u8; 43] = [0; 43];\n    for i in 0..11 {\n        combined_array[i]=squad_player_ids[i];\n    }\n    for i in 0..32 {\n        combined_array[i+11]=player_ids_salt[i];\n    }\n    combined_array\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut conv: Field = 0;\n    conv = (conv * 256) + (array[0] as Field);\n    conv\n}\n\nfn compute_merkle_root(leaf: u8, leaf_index: u8, proof: [[u8; 32]; MERKLE_DEPTH]) -> [u8; 32] {\n    let mut computed_hash: [u8; 32] = [0; 32];\n    computed_hash[0]=leaf;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index % 2 == 0 {\n            computed_hash = std::hash::keccak256(concatenate_leafs(computed_hash, proof[i]), 64);\n        } else {\n            computed_hash = std::hash::keccak256(concatenate_leafs(proof[i], computed_hash), 64);\n        }\n    }\n    computed_hash\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/luffy/circuits/src/main.nr"
    },
    "40": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "41": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "42": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
