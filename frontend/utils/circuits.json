{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 253927469710476017,
  "abi": {
    "parameters": [
      {
        "name": "signer_pub_x_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signer_pub_y_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "squad_player_ids",
        "type": {
          "kind": "array",
          "length": 11,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "squad_points",
        "type": {
          "kind": "array",
          "length": 11,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "player_points_merkle_paths",
        "type": {
          "kind": "array",
          "length": 11,
          "type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "array",
              "length": 32,
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "player_points_root",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "squad_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "total_points",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "player_points_merkle_paths": [{ "start": 150, "end": 1558 }],
      "player_points_root": [{ "start": 1558, "end": 1590 }],
      "signature": [{ "start": 64, "end": 128 }],
      "signer_pub_x_key": [{ "start": 0, "end": 32 }],
      "signer_pub_y_key": [{ "start": 32, "end": 64 }],
      "squad_hash": [{ "start": 1590, "end": 1622 }],
      "squad_player_ids": [{ "start": 128, "end": 139 }],
      "squad_points": [{ "start": 139, "end": 150 }],
      "total_points": [{ "start": 1622, "end": 1623 }]
    },
    "return_type": null,
    "return_witnesses": []
  },
  "bytecode": "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",
  "debug_symbols": "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zDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjzDzGzGPMPMbMY8w8xsxjwjx++PBv",
  "file_map": {
    "39": {
      "source": "use dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 4;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    squad_player_ids: [u8; 11],\n    squad_points: [u8; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    player_points_root: pub [u8; 32],\n    squad_hash: pub [u8; 32],\n    total_points: pub u8\n) {\n    // verify ECDSA signature\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, squad_hash);\n    assert(recoveredAddress == computedAddress);\n\n    // verify the merkle path of the point to confirm that is actually the points of the player\n    // for i in squad_player_ids {\n    //     let computed_root= compute_merkle_root(\n    //         squad_points[i], // leaf\n    //         squad_player_ids[i], // index\n    //         player_points_merkle_paths[i] // merkle proof\n    //     );\n    //     assert(computed_root == player_points_root);\n    // }\n\n    // sum all points and return it back to the contract\n    let mut calculated_total_points: u8 = 0;\n    for point in squad_points {\n        calculated_total_points+=point as u8;\n    }\n\n    assert(calculated_total_points == total_points);\n}\n\nfn concatenate_player_ids_with_salt(squad_player_ids: [u8; 11], player_ids_salt: [u8; 32]) -> [u8; 43] {\n    let mut combined_array: [u8; 43] = [0; 43];\n    for i in 0..11 {\n        combined_array[i]=squad_player_ids[i];\n    }\n    for i in 0..32 {\n        combined_array[i+11]=player_ids_salt[i];\n    }\n    combined_array\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut conv: Field = 0;\n    conv = (conv * 256) + (array[0] as Field);\n    conv\n}\n\nfn compute_merkle_root(leaf: u8, leaf_index: u8, proof: [[u8; 32]; MERKLE_DEPTH]) -> [u8; 32] {\n    let mut computed_hash: [u8; 32] = [0; 32];\n    computed_hash[0]=leaf;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index % 2 == 0 {\n            computed_hash = std::hash::keccak256(concatenate_leafs(computed_hash, proof[i]), 64);\n        } else {\n            computed_hash = std::hash::keccak256(concatenate_leafs(proof[i], computed_hash), 64);\n        }\n    }\n    computed_hash\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/luffy/circuits/src/main.nr"
    },
    "40": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "41": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "42": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
