{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":15269888763319317223,"abi":{"parameters":[{"name":"signer_pub_x_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signer_pub_y_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"squad_player_ids","type":{"kind":"array","length":11,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"squad_secret","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"squad_points","type":{"kind":"array","length":11,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"player_points_merkle_paths","type":{"kind":"array","length":11,"type":{"kind":"array","length":4,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}},"visibility":"private"},{"name":"player_points_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"squad_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"param_witnesses":{"player_points_merkle_paths":[{"start":182,"end":1590}],"player_points_root":[{"start":1590,"end":1622}],"signature":[{"start":64,"end":128}],"signer_pub_x_key":[{"start":0,"end":32}],"signer_pub_y_key":[{"start":32,"end":64}],"squad_hash":[{"start":1622,"end":1654}],"squad_player_ids":[{"start":128,"end":139}],"squad_points":[{"start":171,"end":182}],"squad_secret":[{"start":139,"end":171}]},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[1881]},"bytecode":"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","debug_symbols":"vdzdapvZGYbhc/F2KHre9Z9TKd0I7RQGhkxpshdy7o1V2ylEapwrzOyZ4MdSxCUh3176Pj389vvf33389ff3Hx7efnrIHP3h7V8/PXz417v3j//w4eO7f398eNtHf/Pwy/t/PLwdc35+8/DPX3/75eFtO5//9uZxM2Azb23GOk+bmfXtZsFmw+b8+GZeYBPYFGwabDpsBmzAwQQHExxMcLDAwQIHCxwscLDAwQIHCxwscLDAwQIHGxxscLDBwQYHGxxscLDBwQYH+6aDLw/N02at9r+bN998a2rX0/em9fPyzT1PN3B+9gbavjzfQE/75gbO5Y++gZscd1tPozP3/7+BGuPpW+t8fQfQL7fuS+r53ULq1n2pP+q+/PfHt5/88S3Pd7+1/p3/6nfgnP4n3pfvEbj5DD47z6NLvn1rd6aMloy2jM6Pj9blIqPIqGTUZNRlNGQ0ZbRktGUkIiIiIiIiIiIiIiIiIiIiIiIiIiIiSkSUiCgRUSKiRESJiBIRJSJKRJSIaCKiiYgGIr68B/7L7ZeJmv353caXL7++3ej1ddh1OHQ4dbh0uHV4cHj7JeQ1w+iwdKhySuWUyimVUyqnVE6pnKZymsppKqepnKZymsppKqepnKZymsrpKqernK5yusrpKqernK5yusrpKqernKFyhsoZKmeonKFyhsoZKmeonKFyhsqZKmeqnKlypsqZKmeqnKlypsqZKmeqnKVylspZKmepnKVylspZKmepnKVylsrZKmernK1ytsrZKmernK1ytsrZKmernKNyjso5KueonKNyjso5KueonKNyjsrJ5cLL8LJ4yTXwwjnwwj3wwkHwwkXwwknwwobChsKGwoa8KHtS9qbsUdmrsmdl7srhsBwuy+G0HG7L4bgcrsvhvBzuy+HAHC7M4cQcbszhyByuzOHMHO7M4dAcLs3h1BxuzeHYHK7N4dyc7n8dZUNcnMPJOdycw9E5XJ3D2TncncPhOVyew+k53J7D8Tlcn8P5OdyfwwE6XKDDCTrcoMMROtPPabAh7tDhEB0u0eEUHW7R4RgdrtHhHB3u0Vl+2IcNcZION+lwlA5X6XCWDnfpcJgOl+lwms72E2NsiOt0OE+H+3Q4UIcLdThRhxt1OFKHK3WOHzv0c4d88JA7dXGnLu7UxZ26uFMXd+riTl3cqYs7dcUPr7Ih7tTFnbq4Uxd36uJOXdypizt1+flnPwD9Eyeg2ZCfgfZD0H4K2o9B+zloPwjNnbq4Uxd36mp+jJ4Ncacu7tTFnbq4Uxd36uJOXdypizt1caeu7p/FYEPcqYs7dXGnLu7UxZ26uFMXd+riTl3cqYs7dXGnLu7UxZ26uFMXd+riTl3cqYs7dXGnLu7UNf1TYWyIO3Vxpy7u1MWdurhTF3fq4k5d3KmLO3Ut/2ghG+JOXdypizt1cacu7tR1r/yuelmufnu5dHmna672/BHsL1+228vOy9v3do32shzn9nLz8uCy3WmMr1mGlwsf23anoL1meXR5p6C9Zhlelj62dwraa5adl4OXk5eLl3cMza/LldvLo8viZ1nxs6zYULGhYkPFhooNFRuqzUt+pW5sqLGhxoYaG2psqLGhxoYaG2psqLGhzoY6G+psqLOhzoY6G+psqLOhzoY6GxpsaLChezXru78BtHs16xXLycvFy83LO79FnvPy2F7WzeW9mvWK5Z3fIk9/ubdn3F4WLxsvOy8HLycvFy83L48u79WsVyzZ0GJDiw0tNrTY0GJDiw0tNrTY0GZDmw1tNrTZ0GZDmw1tNrTZ0GZDmw0dNnTY0CFDp+FlHh+HXYdDh1OHS4dbhweHdsrpcRgdlg5VTqmcUjmlckrllMopldNUTlM5TeU0ldNUTlM5TeU0ldNUTlM5XeV0ldNVTlc5XeV0ldNVTlc5XeV0lTNUzlA5Q+UMlTNUzlA5Q+UMlTNUzlA5U+VMlTNVzlQ5U+VMlTNVzlQ5U+VMlbNUzlI5S+UslbNUzlI5S+UslbNUzlI5W+VslbNVzlY5W+VslbNVzlY5W+VslXNUzlE5R+UclXNUzlE5R+UclXNUzlE5eJnH6zK8LF5yDbxwDrxwD7xwELxwEbxwErywobChsKGwIS/KnpS9KXtU9qrsWZm7cjgsh8tyOC2H23I4Lofrcjgvh/tyODCHC3M4MYcbczgyhytzODOHO3M4NIdLczg1h1tzODaHa3M4N6f7X0fZEBfncHION+dwdA5X53B2DnfncHgOl+dweg6353B8DtfncH4O9+dwgA4X6HCCDjfocITO9HMabIg7dDhEh0t0OEWHW3Q4RodrdDhHh3t0lh/2YUOcpMNNOhylw1U6nKXDXTocpsNlOpyms/3EGBviOh3O0+E+HQ7U4UIdTtThRh2O1OFKnePHDv3cIR885E5d3KmLOzVe5vG65NOH3KmLO3Vxpy7u1BU/vMqGuFMXd+riTl3cqYs7dXGnLu7U5eef/QD0T5yAZkN+BtoPQfspaD8G7eeg/SA0d+riTl3cqav5MXo2xJ26uFMXd+riTl3cqYs7dXGnLu7UxZ26un8Wgw1xpy7u1MWdurhTF3fq4k5d3KmLO3Vxpy7u1MWdurhTF3fq4k5d3KmLO3Vxpy7u1MWdurhT1/RPhbEh7tTFnbq4Uxd36uJOXdypizt1cacu7tS1/KOFbIg7dXGnLu7UxZ26uFPjZR6vy6VLu8zjddl5SRftuS43Lw8u8TKP12V4ufCxxcs8XpdHl3aZx+syvCx9bO0yj9dl5+Xg5eTl4iVd5vG6PLosfpYVP8uKDRUbKjZUbKjYULGh2rzkV+rGhhobamyosaHGhhobamyosaHGhhob6myos6HOhjob6myos6HOhjob6myos6HBhgYbsss8XpeDl5OXi5ebl3SZx8elXebxuqRLY12XxcvGy87LwcvJy8XLzcujS7vM43XJhhYbWmxosaHFhhYbWmxosaHFhjYb2mxos6HNhjYb2mxos6HNhjYb2mzosKHDhn78Mo+fP/8H","file_map":{"39":{"source":"use dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 4;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    squad_player_ids: [u8; 11],\n    squad_secret: [u8; 32],\n    squad_points: [u8; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    player_points_root: pub [u8; 32],\n    squad_hash: pub [u8; 32]\n) -> pub Field {\n    // verify squad hash\n    let computed_player_ids_hash = std::hash::keccak256(\n        concatenate_player_ids_with_salt(squad_player_ids, squad_secret),\n        43\n    );\n    assert(computed_player_ids_hash == squad_hash);\n    // verify ECDSA signature\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(\n        signer_pub_x_key,\n        signer_pub_y_key,\n        signature,\n        computed_player_ids_hash\n    );\n    assert(recoveredAddress == computedAddress);\n    // verify the merkle path of the point to confirm that is actually the points of the player\n    // for i in squad_player_ids {\n    //     let computed_root= compute_merkle_root(\n    //         squad_points[i], // leaf\n    //         squad_player_ids[i], // index\n    //         player_points_merkle_paths[i] // merkle proof\n    //     );\n    //     assert(computed_root == player_points_root);\n    // }\n    recoveredAddress\n    // // sum all points and return it back to the contract\n    // let mut totalPoints: u8= 0;\n    // for point in squad_points {\n    //     totalPoints+=point as u8;\n    // }\n    // totalPoints\n}\n\nfn concatenate_player_ids_with_salt(squad_player_ids: [u8; 11], player_ids_salt: [u8; 32]) -> [u8; 43] {\n    let mut combined_array: [u8; 43] = [0; 43];\n    for i in 0..11 {\n        combined_array[i]=squad_player_ids[i];\n    }\n    for i in 0..32 {\n        combined_array[i+11]=player_ids_salt[i];\n    }\n    combined_array\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut conv: Field = 0;\n    conv = (conv * 256) + (array[0] as Field);\n    conv\n}\n\nfn compute_merkle_root(leaf: u8, leaf_index: u8, proof: [[u8; 32]; MERKLE_DEPTH]) -> [u8; 32] {\n    let mut computed_hash: [u8; 32] = [0; 32];\n    computed_hash[0]=leaf;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index % 2 == 0 {\n            computed_hash = std::hash::keccak256(concatenate_leafs(computed_hash, proof[i]), 64);\n        } else {\n            computed_hash = std::hash::keccak256(concatenate_leafs(proof[i], computed_hash), 64);\n        }\n    }\n    computed_hash\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n","path":"/Users/gabrielantonyxaviour/Developer/projects/luffy/circuits/src/main.nr"},"40":{"source":"use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"},"41":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"},"42":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"}}}