{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 10311687216356749624,
  "abi": {
    "parameters": [
      {
        "name": "signer_pub_x_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signer_pub_y_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "squad_player_ids",
        "type": {
          "kind": "array",
          "length": 11,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "squad_points",
        "type": {
          "kind": "array",
          "length": 11,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "player_points_merkle_paths",
        "type": {
          "kind": "array",
          "length": 11,
          "type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "array",
              "length": 32,
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "player_points_root",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "squad_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "player_points_merkle_paths": [{ "start": 150, "end": 1558 }],
      "player_points_root": [{ "start": 1558, "end": 1590 }],
      "signature": [{ "start": 64, "end": 128 }],
      "signer_pub_x_key": [{ "start": 0, "end": 32 }],
      "signer_pub_y_key": [{ "start": 32, "end": 64 }],
      "squad_hash": [{ "start": 1590, "end": 1622 }],
      "squad_player_ids": [{ "start": 128, "end": 139 }],
      "squad_points": [{ "start": 139, "end": 150 }]
    },
    "return_type": {
      "abi_type": { "kind": "integer", "sign": "unsigned", "width": 8 },
      "visibility": "public"
    },
    "return_witnesses": [1825]
  },
  "bytecode": "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",
  "debug_symbols": "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mceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHmMmceYeYyZx5h5jJnHmHlMmMd37/4F",
  "file_map": {
    "39": {
      "source": "use dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 4;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    squad_player_ids: [u8; 11],\n    squad_points: [u8; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    player_points_root: pub [u8; 32],\n    squad_hash: pub [u8; 32]\n) -> pub u8 {\n    // verify ECDSA signature\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, squad_hash);\n    assert(recoveredAddress == computedAddress);\n\n    // verify the merkle path of the point to confirm that is actually the points of the player\n    // for i in squad_player_ids {\n    //     let computed_root= compute_merkle_root(\n    //         squad_points[i], // leaf\n    //         squad_player_ids[i], // index\n    //         player_points_merkle_paths[i] // merkle proof\n    //     );\n    //     assert(computed_root == player_points_root);\n    // }\n\n    // sum all points and return it back to the contract\n    let mut totalPoints: u8= 0;\n    for point in squad_points {\n        totalPoints+=point as u8;\n    }\n\n    totalPoints\n}\n\nfn concatenate_player_ids_with_salt(squad_player_ids: [u8; 11], player_ids_salt: [u8; 32]) -> [u8; 43] {\n    let mut combined_array: [u8; 43] = [0; 43];\n    for i in 0..11 {\n        combined_array[i]=squad_player_ids[i];\n    }\n    for i in 0..32 {\n        combined_array[i+11]=player_ids_salt[i];\n    }\n    combined_array\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut conv: Field = 0;\n    conv = (conv * 256) + (array[0] as Field);\n    conv\n}\n\nfn compute_merkle_root(leaf: u8, leaf_index: u8, proof: [[u8; 32]; MERKLE_DEPTH]) -> [u8; 32] {\n    let mut computed_hash: [u8; 32] = [0; 32];\n    computed_hash[0]=leaf;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index % 2 == 0 {\n            computed_hash = std::hash::keccak256(concatenate_leafs(computed_hash, proof[i]), 64);\n        } else {\n            computed_hash = std::hash::keccak256(concatenate_leafs(proof[i], computed_hash), 64);\n        }\n    }\n    computed_hash\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/luffy/circuits/src/main.nr"
    },
    "40": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "41": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "42": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
