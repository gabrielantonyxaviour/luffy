{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":11383801693371302274,"abi":{"parameters":[{"name":"signer_pub_x_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signer_pub_y_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"squad_player_ids","type":{"kind":"array","length":11,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"squad_secret","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"squad_points","type":{"kind":"array","length":11,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"player_points_merkle_paths","type":{"kind":"array","length":11,"type":{"kind":"array","length":4,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}},"visibility":"private"},{"name":"player_points_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"squad_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"param_witnesses":{"player_points_merkle_paths":[{"start":182,"end":1590}],"player_points_root":[{"start":1590,"end":1622}],"signature":[{"start":64,"end":128}],"signer_pub_x_key":[{"start":0,"end":32}],"signer_pub_y_key":[{"start":32,"end":64}],"squad_hash":[{"start":1622,"end":1654}],"squad_player_ids":[{"start":128,"end":139}],"squad_points":[{"start":171,"end":182}],"squad_secret":[{"start":139,"end":171}]},"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},"return_witnesses":[1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653]},"bytecode":"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","debug_symbols":"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","file_map":{"39":{"source":"use dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 4;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    squad_player_ids: [u8; 11],\n    squad_secret: [u8; 32],\n    squad_points: [u8; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    player_points_root: pub [u8; 32],\n    squad_hash: pub [u8; 32]\n) -> pub [u8; 32] {\n    // verify squad hash\n    let computed_player_ids_hash = std::hash::keccak256(\n        concatenate_player_ids_with_salt(squad_player_ids, squad_secret),\n        43\n    );\n    assert(computed_player_ids_hash == squad_hash);\n    // verify ECDSA signature\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(\n        signer_pub_x_key,\n        signer_pub_y_key,\n        signature,\n        computed_player_ids_hash\n    );\n    assert(recoveredAddress == computedAddress);\n    // verify the merkle path of the point to confirm that is actually the points of the player\n    // for i in squad_player_ids {\n    //     let computed_root= compute_merkle_root(\n    //         squad_points[i], // leaf\n    //         squad_player_ids[i], // index\n    //         player_points_merkle_paths[i] // merkle proof\n    //     );\n    //     assert(computed_root == player_points_root);\n    // }\n    computed_player_ids_hash\n    // // sum all points and return it back to the contract\n    // let mut totalPoints: u8= 0;\n    // for point in squad_points {\n    //     totalPoints+=point as u8;\n    // }\n    // totalPoints\n}\n\nfn concatenate_player_ids_with_salt(squad_player_ids: [u8; 11], player_ids_salt: [u8; 32]) -> [u8; 43] {\n    let mut combined_array: [u8; 43] = [0; 43];\n    for i in 0..11 {\n        combined_array[i]=squad_player_ids[i];\n    }\n    for i in 0..32 {\n        combined_array[i+11]=player_ids_salt[i];\n    }\n    combined_array\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut conv: Field = 0;\n    conv = (conv * 256) + (array[0] as Field);\n    conv\n}\n\nfn compute_merkle_root(leaf: u8, leaf_index: u8, proof: [[u8; 32]; MERKLE_DEPTH]) -> [u8; 32] {\n    let mut computed_hash: [u8; 32] = [0; 32];\n    computed_hash[0]=leaf;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index % 2 == 0 {\n            computed_hash = std::hash::keccak256(concatenate_leafs(computed_hash, proof[i]), 64);\n        } else {\n            computed_hash = std::hash::keccak256(concatenate_leafs(proof[i], computed_hash), 64);\n        }\n    }\n    computed_hash\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n","path":"/Users/gabrielantonyxaviour/Developer/projects/luffy/circuits/src/main.nr"},"40":{"source":"use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"},"41":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"},"42":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"}}}